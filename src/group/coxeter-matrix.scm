;;; ----------------------------------------------------------------------
;;; Copyright 2005 Alexey Radul and Rebecca Frankel.
;;; ----------------------------------------------------------------------
;;; This file is part of The Symmetriad.
;;; 
;;; The Symmetriad is free software; you can redistribute it and/or modify
;;; it under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 2 of the License, or
;;; (at your option) any later version.
;;; 
;;; The Symmetriad is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;; 
;;; You should have received a copy of the GNU General Public License
;;; along with The Symmetriad; if not, write to the Free Software
;;; Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
;;; ----------------------------------------------------------------------

(declare (usual-integrations))

;;; This file contains the definition of the coxeter matrix data type,
;;; and functions that create coxeter matrices, for the possible
;;; coxeter groups

;; Coxeter matrix data type
(define-structure 
  (coxeter-matrix
   (constructor %create-coxeter-matrix)
   (conc-name cm:))
  (matrix #f read-only #t))

;; Makes coxeter matrix of size n, 
;; filling the rows with values generated by proc
(define (make-coxeter-matrix n proc)
  (%create-coxeter-matrix (m:generate n n proc)))

(define (cm:dimension cox-matrix)
  (m:num-rows (cm:matrix cox-matrix)))

(define (cm:matrix-ref cox-matrix row col)
  (matrix-ref (cm:matrix cox-matrix) row col))

(define (cm:cross-product cm1 cm2)
  (let ((dim1 (cm:dimension cm1))
	(dim2 (cm:dimension cm2)))
    (make-coxeter-matrix
     (+ dim1 dim2)
     (lambda (i j)
       (cond ((and (< i dim1) (< j dim1))
	      (cm:matrix-ref cm1 i j))
	     ((and (>= i dim1) (>= j dim1))
	      (cm:matrix-ref cm2 (- i dim1) (- j dim1)))
	     (else 2))))))


(define (make-cox-matrix-A n)
  (make-coxeter-matrix 
   n
   (lambda (i j)
     (cond ((= i j) 1)
	   ((= (- i j) 1) 3)
	   ((= (- j i) 1) 3)
	   (else 2)))))

(define (make-cox-matrix-B/C n)
  (make-coxeter-matrix 
   n
   (lambda (i j)
     (cond ((= i j) 1)
	   ((= (- i j) 1)
	    (if (= i (- n 1))
		4
		3))
	   ((= (- j i) 1)
	    (if (= j (- n 1))
		4
		3))
	   (else 2)))))

(define (make-cox-matrix-D n)
  (make-coxeter-matrix 
   n
   (lambda (i j)
     (cond ((= i j) 1)
	   ((= i (- n 1))
	    (if (= (- i j) 2) 3 2))
	   ((= j (- n 1))
	    (if (= (- j i) 2) 3 2))
	   ((= (- i j) 1) 3)
	   ((= (- j i) 1) 3)
	   (else 2)))))

(define (make-cox-matrix-F n)
  (assert (= 4 n) (string-append "F must be dimension 4, not " 
				 (number->string n) "."))
  (make-coxeter-matrix 
   4
   (lambda (i j)
     (cond ((= i j) 1)
	   ((= (- i j) 1)
	    (if (= i 2) 4 3))
	   ((= (- j i) 1)
	    (if (= j 2) 4 3))
	   (else 2)))))

(define (make-cox-matrix-H n)
  (assert (or (= n 3) (= n 4)) "H must be dimension 3 or 4")
  (make-coxeter-matrix 
   n
   (lambda (i j)
     (cond ((= i j) 1)
	   ((= (- i j) 1)
	    (if (= i (- n 1)) 5 3))
	   ((= (- j i) 1)
	    (if (= j (- n 1)) 5 3))
	   (else 2)))))

(define (make-cox-matrix-I2 m)
  (make-coxeter-matrix 
   2
   (lambda (i j)
     (if (= i j) 1 m))))
